// - Validates BEFORE WebMethod executes (SoapExtension: BeforeDeserialize)
// - Validates ONLY the method(s) you decorate with the attribute
// - Validates ONLY the parameter name you specify
// - Catches: string sent to long/int, out-of-range, custom min/max
// - Responds with either SOAP Fault or HTTP 400 (configurable)
// - Logs errors by calling an existing REST API (configurable)

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Linq;

#region Enums + Attribute

public enum NumericKind
{
    Int32,
    Int64
}

public enum ResponseMode
{
    SoapFault, // Standard SOAP fault (typically HTTP 500 + SOAP Fault body)
    Http400    // HTTP 400 with either plain text or SOAP fault XML body (configurable)
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
public sealed class SoapRangeValidateAttribute : SoapExtensionAttribute
{
    public SoapRangeValidateAttribute(string paramName, NumericKind kind, string min, string max)
    {
        ParamName = paramName ?? throw new ArgumentNullException(nameof(paramName));
        Kind = kind;
        Min = min ?? throw new ArgumentNullException(nameof(min));
        Max = max ?? throw new ArgumentNullException(nameof(max));
    }

    public string ParamName { get; }
    public NumericKind Kind { get; }
    public string Min { get; }
    public string Max { get; }

    // Your user-defined message returned to caller on validation failure
    public string ErrorMessage { get; set; } = "Invalid request parameter.";

    // Choose how to respond
    public ResponseMode ResponseMode { get; set; } = ResponseMode.SoapFault;

    // If ResponseMode.Http400 and you still want SOAP Fault XML body in response
    public bool Http400ReturnsSoapBody { get; set; } = false;

    // Logging REST API endpoint (per attribute/method; optional)
    public string LogApiUrl { get; set; } = "";

    // Optional bearer token (leave empty if not needed)
    public string LogApiBearerToken { get; set; } = "";

    // Keep small so validation never slows SOAP too much
    public int LogApiTimeoutSeconds { get; set; } = 2;

    public override Type ExtensionType => typeof(SoapRangeValidateExtension);

    // Lower runs earlier
    public override int Priority { get; set; } = 1;
}

#endregion

#region REST Logger (calls your existing API)

internal static class RestErrorLogger
{
    // We cache clients by (timeout + token) to avoid creating new HttpClient per request
    private static readonly object _lock = new object();
    private static readonly Dictionary<string, HttpClient> _clients = new Dictionary<string, HttpClient>(StringComparer.Ordinal);

    private static HttpClient GetClient(string bearerToken, int timeoutSeconds)
    {
        bearerToken = bearerToken ?? "";
        timeoutSeconds = timeoutSeconds <= 0 ? 2 : timeoutSeconds;

        string key = $"{timeoutSeconds}|{bearerToken}";
        lock (_lock)
        {
            if (_clients.TryGetValue(key, out var existing))
                return existing;

            var c = new HttpClient
            {
                Timeout = TimeSpan.FromSeconds(timeoutSeconds)
            };
            c.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

            if (!string.IsNullOrWhiteSpace(bearerToken))
                c.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", bearerToken);

            _clients[key] = c;
            return c;
        }
    }

    // NOTE: Uses application/x-www-form-urlencoded to avoid JSON serializer dependencies.
    // If your logging API requires JSON, tell me the required schema and Iâ€™ll adjust.
    public static void Log(
        string logApiUrl,
        string bearerToken,
        int timeoutSeconds,
        string message,
        Exception ex = null,
        string soapSnippet = null)
    {
        if (string.IsNullOrWhiteSpace(logApiUrl))
            return;

        try
        {
            var ctx = HttpContext.Current;

            var payload = new Dictionary<string, string>
            {
                ["source"] = "ASMX-SoapExtension",
                ["timestampUtc"] = DateTime.UtcNow.ToString("o"),
                ["message"] = message,
                ["exceptionMessage"] = ex?.Message,
                ["stackTrace"] = ex?.StackTrace,
                ["url"] = ctx?.Request?.Url?.ToString(),
                ["httpMethod"] = ctx?.Request?.HttpMethod,
                ["clientIp"] = ctx?.Request?.UserHostAddress,
                ["soapSnippet"] = soapSnippet
            };

            // Remove nulls
            var cleaned = payload.Where(kv => !string.IsNullOrWhiteSpace(kv.Value))
                                 .ToDictionary(kv => kv.Key, kv => kv.Value);

            var client = GetClient(bearerToken, timeoutSeconds);
            using var content = new FormUrlEncodedContent(cleaned);

            // Sync send (SoapExtension pipeline). Keep timeout small.
            client.PostAsync(logApiUrl, content).GetAwaiter().GetResult();
        }
        catch
        {
            // Never throw from logger
        }
    }
}

#endregion

#region SoapExtension

public sealed class SoapRangeValidateExtension : SoapExtension
{
    private sealed class Rule
    {
        public string MethodName { get; init; } = "";
        public string ParamName { get; init; } = "";
        public NumericKind Kind { get; init; }
        public BigInteger Min { get; init; }
        public BigInteger Max { get; init; }
        public string ErrorMessage { get; init; } = "Invalid request parameter.";
        public ResponseMode ResponseMode { get; init; } = ResponseMode.SoapFault;
        public bool Http400ReturnsSoapBody { get; init; }

        public string LogApiUrl { get; init; } = "";
        public string LogApiBearerToken { get; init; } = "";
        public int LogApiTimeoutSeconds { get; init; } = 2;
    }

    private Rule _rule = new Rule();
    private Stream _oldStream;
    private MemoryStream _bufferStream;

    public override object GetInitializer(Type serviceType) => new Rule();

    public override object GetInitializer(LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute)
    {
        var a = (SoapRangeValidateAttribute)attribute;

        if (!BigInteger.TryParse(a.Min, out var min))
            throw new InvalidOperationException($"Invalid Min value '{a.Min}'.");
        if (!BigInteger.TryParse(a.Max, out var max))
            throw new InvalidOperationException($"Invalid Max value '{a.Max}'.");
        if (min > max)
            throw new InvalidOperationException("Min cannot be greater than Max.");

        return new Rule
        {
            MethodName = methodInfo.Name, // attribute applied per method
            ParamName = a.ParamName,
            Kind = a.Kind,
            Min = min,
            Max = max,
            ErrorMessage = a.ErrorMessage,
            ResponseMode = a.ResponseMode,
            Http400ReturnsSoapBody = a.Http400ReturnsSoapBody,
            LogApiUrl = a.LogApiUrl ?? "",
            LogApiBearerToken = a.LogApiBearerToken ?? "",
            LogApiTimeoutSeconds = a.LogApiTimeoutSeconds <= 0 ? 2 : a.LogApiTimeoutSeconds
        };
    }

    public override void Initialize(object initializer)
    {
        _rule = (Rule)initializer;
    }

    public override Stream ChainStream(Stream stream)
    {
        _oldStream = stream;
        _bufferStream = new MemoryStream();
        return _bufferStream;
    }

    public override void ProcessMessage(SoapMessage message)
    {
        // BEFORE deserialization => catches string->numeric and out-of-range issues
        if (message.Stage != SoapMessageStage.BeforeDeserialize)
            return;

        string soapXml = ReadAllFrom(_bufferStream);

        try
        {
            // Validate only if this SOAP request is calling the decorated method
            if (!IsCallForMethod(soapXml, _rule.MethodName))
            {
                WriteBack(soapXml, _oldStream);
                return;
            }

            // Extract the parameter value (string) from the SOAP body
            string raw = ExtractParamValue(soapXml, _rule.MethodName, _rule.ParamName);
            if (raw == null)
            {
                Fail(_rule, $"Missing required parameter '{_rule.ParamName}'.", soapXml);
                return;
            }

            raw = raw.Trim();

            // Validate: numeric format + .NET range + custom min/max
            if (!ValidateNumeric(raw, _rule))
            {
                Fail(_rule, _rule.ErrorMessage, soapXml);
                return;
            }

            // Pass through unchanged so ASMX can deserialize + invoke
            WriteBack(soapXml, _oldStream);
        }
        catch (Exception ex)
        {
            // Log unexpected errors and fail safely
            RestErrorLogger.Log(_rule.LogApiUrl, _rule.LogApiBearerToken, _rule.LogApiTimeoutSeconds,
                "Unexpected error in SOAP validation.", ex, SafeSnippet(soapXml));

            // Fail with a generic message (or use ex.Message if you want)
            Fail(_rule, "Invalid request.", soapXml);
        }
    }

    private static bool ValidateNumeric(string raw, Rule rule)
    {
        // If user sends "ABC" instead of number => fail
        if (!BigInteger.TryParse(raw, out var val))
            return false;

        // Validate base .NET type range too
        if (rule.Kind == NumericKind.Int32)
        {
            if (val < int.MinValue || val > int.MaxValue)
                return false;
        }
        else
        {
            if (val < long.MinValue || val > long.MaxValue)
                return false;
        }

        // Validate custom allowed range
        if (val < rule.Min || val > rule.Max)
            return false;

        return true;
    }

    private static bool IsCallForMethod(string soapXml, string methodName)
    {
        // Namespace-agnostic: find <Body> then look for element local-name == methodName
        var doc = XDocument.Parse(soapXml, LoadOptions.None);

        var body = doc.Descendants().FirstOrDefault(x => x.Name.LocalName == "Body");
        if (body == null)
            return false;

        return body.Descendants().Any(x => x.Name.LocalName == methodName);
    }

    private static string ExtractParamValue(string soapXml, string methodName, string paramName)
    {
        var doc = XDocument.Parse(soapXml, LoadOptions.None);

        var body = doc.Descendants().FirstOrDefault(x => x.Name.LocalName == "Body");
        if (body == null)
            return null;

        var op = body.Descendants().FirstOrDefault(x => x.Name.LocalName == methodName);
        if (op == null)
            return null;

        // Typical ASMX params are direct children of the operation element
        var p = op.Elements().FirstOrDefault(x => x.Name.LocalName == paramName);
        return p?.Value;
    }

    private static void Fail(Rule rule, string message, string soapXml)
    {
        // Log to REST API (non-blocking pattern via short timeout; exceptions swallowed)
        RestErrorLogger.Log(rule.LogApiUrl, rule.LogApiBearerToken, rule.LogApiTimeoutSeconds,
            "SOAP Validation Failed: " + message, null, SafeSnippet(soapXml));

        if (rule.ResponseMode == ResponseMode.Http400)
        {
            var ctx = HttpContext.Current;
            if (ctx != null)
            {
                ctx.Response.Clear();
                ctx.Response.StatusCode = 400;

                if (rule.Http400ReturnsSoapBody)
                {
                    ctx.Response.ContentType = "text/xml; charset=utf-8";
                    ctx.Response.Write(BuildSoapFaultXml(message));
                }
                else
                {
                    ctx.Response.ContentType = "text/plain; charset=utf-8";
                    ctx.Response.Write(message);
                }

                // Stop pipeline before WebMethod executes
                ctx.ApplicationInstance?.CompleteRequest();
                return;
            }

            // Fallback
            ThrowSoapFault(message);
        }
        else
        {
            ThrowSoapFault(message);
        }
    }

    private static string ReadAllFrom(MemoryStream ms)
    {
        ms.Position = 0;
        using var sr = new StreamReader(ms, Encoding.UTF8, true, 8192, leaveOpen: true);
        return sr.ReadToEnd();
    }

    private static void WriteBack(string content, Stream target)
    {
        byte[] bytes = Encoding.UTF8.GetBytes(content);
        target.SetLength(0);
        target.Write(bytes, 0, bytes.Length);
        target.Position = 0;
    }

    private static void ThrowSoapFault(string msg)
    {
        throw new SoapException(
            msg,
            new System.Xml.XmlQualifiedName("Client", SoapException.Namespace)
        );
    }

    private static string BuildSoapFaultXml(string msg)
    {
        string safe = System.Security.SecurityElement.Escape(msg);
        return
$@"<?xml version=""1.0"" encoding=""utf-8""?>
<soap:Envelope xmlns:soap=""http://schemas.xmlsoap.org/soap/envelope/"">
  <soap:Body>
    <soap:Fault>
      <faultcode>soap:Client</faultcode>
      <faultstring>{safe}</faultstring>
    </soap:Fault>
  </soap:Body>
</soap:Envelope>";
    }

    private static string SafeSnippet(string soapXml)
    {
        if (string.IsNullOrEmpty(soapXml)) return null;
        // Avoid logging huge payloads or PHI/PII; keep small snippet
        int max = 2000;
        return soapXml.Length <= max ? soapXml : soapXml.Substring(0, max);
    }
}

#endregion

#region Example ASMX WebService Usage

[WebService(Namespace = "http://tempuri.org/")]
public class MyService : WebService
{
    // Example: return HTTP 400 with plain text message + log to REST API
    [WebMethod]
    [SoapRangeValidate("id", NumericKind.Int64, "1", "9999999999",
        ErrorMessage = "Invalid id",
        ResponseMode = ResponseMode.Http400,
        Http400ReturnsSoapBody = false,
        LogApiUrl = "https://your-domain/api/logs",         // <-- change
        LogApiBearerToken = "",                              // <-- optional
        LogApiTimeoutSeconds = 2)]
    public string test123(long id)
    {
        return "SUCCESS";
    }

    // Example: return SOAP fault with custom message + log to REST API
    [WebMethod]
    [SoapRangeValidate("age", NumericKind.Int32, "0", "120",
        ErrorMessage = "Invalid age",
        ResponseMode = ResponseMode.SoapFault,
        LogApiUrl = "https://your-domain/api/logs")]         // <-- change
    public string testInt(int age)
    {
        return "SUCCESS";
    }

    // Example: HTTP 400 but still return SOAP Fault XML body
    [WebMethod]
    [SoapRangeValidate("memberId", NumericKind.Int64, "1", "999999999999",
        ErrorMessage = "Invalid memberId",
        ResponseMode = ResponseMode.Http400,
        Http400ReturnsSoapBody = true,
        LogApiUrl = "https://your-domain/api/logs")]         // <-- change
    public string test400SoapBody(long memberId)
    {
        return "SUCCESS";
    }
}

#endregion
