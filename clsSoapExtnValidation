// .NET Framework 4.8 (ASMX) - Single-file SoapExtension validation + REST logging
// - Validates BEFORE WebMethod executes (BeforeDeserialize)
// - Validates ONLY the method you decorate (attribute on that method)
// - Validates ONLY the parameter name you specify
// - Catches: string -> numeric, out-of-range, custom min/max
// - ResponseMode: SoapFault or Http400
// - Logs failures to an existing REST API (FormUrlEncoded by default)

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Linq;

#region Enums + Attribute

public enum NumericKind
{
    Int32,
    Int64
}

public enum ResponseMode
{
    SoapFault,
    Http400
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
public sealed class SoapRangeValidateAttribute : SoapExtensionAttribute
{
    public SoapRangeValidateAttribute(string paramName, NumericKind kind, string min, string max)
    {
        if (paramName == null) throw new ArgumentNullException("paramName");
        if (min == null) throw new ArgumentNullException("min");
        if (max == null) throw new ArgumentNullException("max");

        ParamName = paramName;
        Kind = kind;
        Min = min;
        Max = max;
    }

    public string ParamName { get; private set; }
    public NumericKind Kind { get; private set; }
    public string Min { get; private set; }
    public string Max { get; private set; }

    public string ErrorMessage { get; set; } = "Invalid request parameter.";
    public ResponseMode ResponseMode { get; set; } = ResponseMode.SoapFault;

    // If ResponseMode.Http400 and you still want SOAP XML fault body
    public bool Http400ReturnsSoapBody { get; set; } = false;

    // REST logging config (optional)
    public string LogApiUrl { get; set; } = "";
    public string LogApiBearerToken { get; set; } = "";
    public int LogApiTimeoutSeconds { get; set; } = 2;

    public override Type ExtensionType
    {
        get { return typeof(SoapRangeValidateExtension); }
    }

    public override int Priority { get; set; } = 1;
}

#endregion

#region REST Logger

internal static class RestErrorLogger
{
    private static readonly object _lock = new object();
    private static readonly Dictionary<string, HttpClient> _clients = new Dictionary<string, HttpClient>(StringComparer.Ordinal);

    private static HttpClient GetClient(string bearerToken, int timeoutSeconds)
    {
        if (bearerToken == null) bearerToken = "";
        if (timeoutSeconds <= 0) timeoutSeconds = 2;

        string key = timeoutSeconds.ToString() + "|" + bearerToken;

        lock (_lock)
        {
            HttpClient existing;
            if (_clients.TryGetValue(key, out existing))
                return existing;

            HttpClient c = new HttpClient();
            c.Timeout = TimeSpan.FromSeconds(timeoutSeconds);
            c.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

            if (!string.IsNullOrWhiteSpace(bearerToken))
                c.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", bearerToken);

            _clients[key] = c;
            return c;
        }
    }

    public static void Log(string logApiUrl, string bearerToken, int timeoutSeconds,
                           string message, Exception ex, string soapSnippet)
    {
        if (string.IsNullOrWhiteSpace(logApiUrl))
            return;

        try
        {
            HttpContext ctx = HttpContext.Current;

            Dictionary<string, string> payload = new Dictionary<string, string>();
            payload["source"] = "ASMX-SoapExtension";
            payload["timestampUtc"] = DateTime.UtcNow.ToString("o");
            payload["message"] = message ?? "";

            if (ex != null)
            {
                payload["exceptionMessage"] = ex.Message;
                payload["stackTrace"] = ex.StackTrace;
            }

            if (ctx != null && ctx.Request != null)
            {
                payload["url"] = ctx.Request.Url != null ? ctx.Request.Url.ToString() : "";
                payload["httpMethod"] = ctx.Request.HttpMethod;
                payload["clientIp"] = ctx.Request.UserHostAddress;
            }

            if (!string.IsNullOrWhiteSpace(soapSnippet))
                payload["soapSnippet"] = soapSnippet;

            // remove blanks
            Dictionary<string, string> cleaned = payload
                .Where(kv => !string.IsNullOrWhiteSpace(kv.Value))
                .ToDictionary(kv => kv.Key, kv => kv.Value);

            HttpClient client = GetClient(bearerToken, timeoutSeconds);

            using (FormUrlEncodedContent content = new FormUrlEncodedContent(cleaned))
            {
                // Sync send (safe with short timeout). Logger must never break SOAP call.
                client.PostAsync(logApiUrl, content).GetAwaiter().GetResult();
            }
        }
        catch
        {
            // never throw from logger
        }
    }
}

#endregion

#region SoapExtension

public sealed class SoapRangeValidateExtension : SoapExtension
{
    private sealed class Rule
    {
        public string MethodName;
        public string ParamName;
        public NumericKind Kind;
        public BigInteger Min;
        public BigInteger Max;
        public string ErrorMessage;
        public ResponseMode ResponseMode;
        public bool Http400ReturnsSoapBody;

        public string LogApiUrl;
        public string LogApiBearerToken;
        public int LogApiTimeoutSeconds;
    }

    private Rule _rule = new Rule();
    private Stream _oldStream;
    private MemoryStream _bufferStream;

    public override object GetInitializer(Type serviceType)
    {
        return new Rule();
    }

    public override object GetInitializer(LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute)
    {
        SoapRangeValidateAttribute a = (SoapRangeValidateAttribute)attribute;

        BigInteger min, max;
        if (!BigInteger.TryParse(a.Min, out min))
            throw new InvalidOperationException("Invalid Min value '" + a.Min + "'.");
        if (!BigInteger.TryParse(a.Max, out max))
            throw new InvalidOperationException("Invalid Max value '" + a.Max + "'.");
        if (min > max)
            throw new InvalidOperationException("Min cannot be greater than Max.");

        Rule r = new Rule();
        r.MethodName = methodInfo.Name;
        r.ParamName = a.ParamName;
        r.Kind = a.Kind;
        r.Min = min;
        r.Max = max;
        r.ErrorMessage = a.ErrorMessage ?? "Invalid request parameter.";
        r.ResponseMode = a.ResponseMode;
        r.Http400ReturnsSoapBody = a.Http400ReturnsSoapBody;
        r.LogApiUrl = a.LogApiUrl ?? "";
        r.LogApiBearerToken = a.LogApiBearerToken ?? "";
        r.LogApiTimeoutSeconds = a.LogApiTimeoutSeconds <= 0 ? 2 : a.LogApiTimeoutSeconds;

        return r;
    }

    public override void Initialize(object initializer)
    {
        _rule = (Rule)initializer;
    }

    public override Stream ChainStream(Stream stream)
    {
        _oldStream = stream;
        _bufferStream = new MemoryStream();
        return _bufferStream;
    }

    public override void ProcessMessage(SoapMessage message)
    {
        if (message.Stage != SoapMessageStage.BeforeDeserialize)
            return;

        string soapXml = ReadAllFrom(_bufferStream);

        try
        {
            if (!IsCallForMethod(soapXml, _rule.MethodName))
            {
                WriteBack(soapXml, _oldStream);
                return;
            }

            string raw = ExtractParamValue(soapXml, _rule.MethodName, _rule.ParamName);
            if (raw == null)
            {
                Fail(_rule, "Missing required parameter '" + _rule.ParamName + "'.", soapXml, null);
                return;
            }

            raw = raw.Trim();

            if (!ValidateNumeric(raw, _rule))
            {
                Fail(_rule, _rule.ErrorMessage, soapXml, null);
                return;
            }

            WriteBack(soapXml, _oldStream);
        }
        catch (Exception ex)
        {
            Fail(_rule, "Invalid request.", soapXml, ex);
        }
    }

    private static bool ValidateNumeric(string raw, Rule rule)
    {
        BigInteger val;
        if (!BigInteger.TryParse(raw, out val))
            return false;

        if (rule.Kind == NumericKind.Int32)
        {
            if (val < int.MinValue || val > int.MaxValue)
                return false;
        }
        else
        {
            if (val < long.MinValue || val > long.MaxValue)
                return false;
        }

        if (val < rule.Min || val > rule.Max)
            return false;

        return true;
    }

    private static bool IsCallForMethod(string soapXml, string methodName)
    {
        XDocument doc = XDocument.Parse(soapXml, LoadOptions.None);
        XElement body = doc.Descendants().FirstOrDefault(x => x.Name.LocalName == "Body");
        if (body == null) return false;
        return body.Descendants().Any(x => x.Name.LocalName == methodName);
    }

    private static string ExtractParamValue(string soapXml, string methodName, string paramName)
    {
        XDocument doc = XDocument.Parse(soapXml, LoadOptions.None);
        XElement body = doc.Descendants().FirstOrDefault(x => x.Name.LocalName == "Body");
        if (body == null) return null;

        XElement op = body.Descendants().FirstOrDefault(x => x.Name.LocalName == methodName);
        if (op == null) return null;

        XElement p = op.Elements().FirstOrDefault(x => x.Name.LocalName == paramName);
        return p != null ? p.Value : null;
    }

    private static void Fail(Rule rule, string message, string soapXml, Exception ex)
    {
        RestErrorLogger.Log(rule.LogApiUrl, rule.LogApiBearerToken, rule.LogApiTimeoutSeconds,
            "SOAP Validation Failed: " + message, ex, SafeSnippet(soapXml));

        if (rule.ResponseMode == ResponseMode.Http400)
        {
            HttpContext ctx = HttpContext.Current;
            if (ctx != null)
            {
                ctx.Response.Clear();
                ctx.Response.StatusCode = 400;

                if (rule.Http400ReturnsSoapBody)
                {
                    ctx.Response.ContentType = "text/xml; charset=utf-8";
                    ctx.Response.Write(BuildSoapFaultXml(message));
                }
                else
                {
                    ctx.Response.ContentType = "text/plain; charset=utf-8";
                    ctx.Response.Write(message);
                }

                ctx.ApplicationInstance.CompleteRequest();
                return;
            }
        }

        // Default SOAP fault (SOAP clients typically expect this)
        throw new SoapException(message, new System.Xml.XmlQualifiedName("Client", SoapException.Namespace));
    }

    private static string ReadAllFrom(MemoryStream ms)
    {
        ms.Position = 0;
        using (StreamReader sr = new StreamReader(ms, Encoding.UTF8, true, 8192, true))
        {
            return sr.ReadToEnd();
        }
    }

    private static void WriteBack(string content, Stream target)
    {
        byte[] bytes = Encoding.UTF8.GetBytes(content);
        target.SetLength(0);
        target.Write(bytes, 0, bytes.Length);
        target.Position = 0;
    }

    private static string BuildSoapFaultXml(string msg)
    {
        string safe = System.Security.SecurityElement.Escape(msg);
        return
@"<?xml version=""1.0"" encoding=""utf-8""?>
<soap:Envelope xmlns:soap=""http://schemas.xmlsoap.org/soap/envelope/"">
  <soap:Body>
    <soap:Fault>
      <faultcode>soap:Client</faultcode>
      <faultstring>" + safe + @"</faultstring>
    </soap:Fault>
  </soap:Body>
</soap:Envelope>";
    }

    private static string SafeSnippet(string soapXml)
    {
        if (string.IsNullOrEmpty(soapXml)) return null;
        int max = 2000;
        return soapXml.Length <= max ? soapXml : soapXml.Substring(0, max);
    }
}

#endregion

#region Example ASMX WebService Usage

[WebService(Namespace = "http://tempuri.org/")]
public class MyService : WebService
{
    // Your exact usage example:
    [WebMethod]
    [SoapRangeValidate("id", NumericKind.Int64, "1", "9999999999",
        ErrorMessage = "Invalid id",
        ResponseMode = ResponseMode.Http400,
        Http400ReturnsSoapBody = false,
        LogApiUrl = "https://your-domain/api/logs",   // <-- change to your REST logging API
        LogApiBearerToken = "",                       // <-- if needed
        LogApiTimeoutSeconds = 2)]
    public string test123(long id)
    {
        return "SUCCESS";
    }

    // SOAP fault response example:
    [WebMethod]
    [SoapRangeValidate("age", NumericKind.Int32, "0", "120",
        ErrorMessage = "Invalid age",
        ResponseMode = ResponseMode.SoapFault,
        LogApiUrl = "https://your-domain/api/logs")]
    public string testInt(int age)
    {
        return "SUCCESS";
    }
}

#endregion
